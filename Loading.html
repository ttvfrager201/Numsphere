<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <link rel="icon" type="image/x-icon" href="https://i.imgur.com/E4FIiRK.png">
  <title>Loading - NumSphere</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      position: relative;
    }
    
    .loading-container {
      text-align: center;
      z-index: 10;
      position: relative;
      max-width: 450px;
      padding: 2rem;
    }
    
    .logo {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      font-weight: 700;
      color: white;
      margin-bottom: 2rem;
      text-decoration: none;
      animation: logoGlow 2s ease-in-out infinite alternate;
    }
    
    .logo-circle {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 15px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      animation: logoCirclePulse 2s ease-in-out infinite;
    }
    
    .logo-inner {
      width: 20px;
      height: 20px;
      border: 3px solid white;
      border-radius: 50%;
      animation: logoInnerSpin 3s linear infinite;
    }
    
    .loading-text {
      font-size: 1.2rem;
      font-weight: 500;
      margin-bottom: 3rem;
      opacity: 0.9;
      animation: textFade 1.5s ease-in-out infinite alternate;
    }
    
    .progress-container {
      width: 100%;
      max-width: 320px;
      height: 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      margin: 2rem auto;
      overflow: hidden;
      position: relative;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
      border-radius: 4px;
      width: 0%;
      transition: width 0.5s ease;
      position: relative;
    }
    
    .progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      animation: progressShimmer 2s linear infinite;
    }
    
    .loading-message {
      font-size: 0.95rem;
      opacity: 0.85;
      margin-top: 1rem;
      min-height: 24px;
      line-height: 1.4;
    }
    
    .connection-status {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin: 1rem 0;
      flex-wrap: wrap;
    }
    
    .server-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      font-size: 0.8rem;
    }
    
    .server-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: statusPulse 1.5s ease-in-out infinite;
    }
    
    .offline-container {
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 12px;
      padding: 1.5rem;
      margin-top: 1.5rem;
      display: none;
    }
    
    .offline-title {
      color: #ffd93d;
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .offline-message {
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.9rem;
      line-height: 1.5;
      margin-bottom: 1.5rem;
    }
    
    .offline-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .error-container {
      background: rgba(255, 107, 107, 0.1);
      border: 1px solid rgba(255, 107, 107, 0.3);
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
      display: none;
    }
    
    .error-message {
      color: #ff6b6b;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
    }
    
    .btn {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s ease;
      margin: 0.25rem;
      text-decoration: none;
      display: inline-block;
    }
    
    .btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .btn-primary {
      background: rgba(69, 183, 209, 0.3);
      border-color: rgba(69, 183, 209, 0.5);
    }
    
    .btn-warning {
      background: rgba(255, 193, 7, 0.3);
      border-color: rgba(255, 193, 7, 0.5);
    }
    
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
      animation: statusPulse 1.5s ease-in-out infinite;
    }
    
    .status-loading { background: #4ecdc4; }
    .status-success { background: #45b7d1; }
    .status-error { background: #ff6b6b; }
    .status-warning { background: #ffd93d; }
    .status-offline { background: #6c757d; }
    
    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      animation: particleFloat 4s linear infinite;
    }
    
    .fade-out {
      animation: fadeOut 0.8s ease-in-out forwards;
    }
    
    @keyframes logoGlow {
      0% { text-shadow: 0 0 20px rgba(255,255,255,0.5); }
      100% { text-shadow: 0 0 30px rgba(255,255,255,0.8), 0 0 40px rgba(255,255,255,0.3); }
    }
    
    @keyframes logoCirclePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    @keyframes logoInnerSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes textFade {
      0% { opacity: 0.7; }
      100% { opacity: 1; }
    }
    
    @keyframes progressShimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    @keyframes particleFloat {
      0% {
        transform: translateY(100vh) translateX(0);
        opacity: 0;
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% {
        transform: translateY(-100px) translateX(100px);
        opacity: 0;
      }
    }
    
    @keyframes statusPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    @keyframes fadeOut {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.95); }
    }

    @media (max-width: 480px) {
      .logo { font-size: 2rem; }
      .loading-container { padding: 1rem; max-width: 350px; }
      .progress-container { max-width: 280px; }
      .offline-actions { flex-direction: column; }
      .connection-status { flex-direction: column; gap: 0.5rem; }
    }
  </style>
</head>
<body>
  <div class="particles" id="particles"></div>
  
  <div class="loading-container" id="loadingContainer">
    <div class="logo">
      <div class="logo-circle">
        <div class="logo-inner"></div>
      </div>
      NumSphere
    </div>
    
    <div class="loading-text">Connecting to NumSphere...</div>
    
    <div class="progress-container">
      <div class="progress-bar" id="progressBar"></div>
    </div>
    
    <div class="loading-message" id="loadingMessage">
      <span class="status-indicator status-loading" id="statusIndicator"></span>
      <span id="messageText">Initializing connection...</span>
    </div>
    
    <div class="connection-status" id="connectionStatus">
      <div class="server-indicator">
        <div class="server-dot status-loading" id="primaryDot"></div>
        <span>Primary Server</span>
      </div>
      <div class="server-indicator">
        <div class="server-dot status-loading" id="backupDot"></div>
        <span>Backup Server</span>
      </div>
    </div>
    
    <div class="offline-container" id="offlineContainer">
      <div class="offline-title">
        <span class="status-indicator status-warning"></span>
        Offline Mode Available
      </div>
      <div class="offline-message">
        Both servers are currently unavailable, but you can still access NumSphere in offline mode with limited functionality.
      </div>
      <div class="offline-actions">
        <button class="btn btn-primary" onclick="continueOffline()">Continue Offline</button>
        <button class="btn" onclick="retryConnection()">Retry Connection</button>
        <button class="btn btn-warning" onclick="goToLogin()">Back to Login</button>
      </div>
    </div>
    
    <div class="error-container" id="errorContainer">
      <div class="error-message" id="errorMessage"></div>
      <div style="text-align: center; margin-top: 1rem;">
        <button class="btn" id="retryBtn" onclick="retryConnection()">Retry Connection</button>
        <button class="btn btn-warning" id="loginBtn" onclick="goToLogin()">Go to Login</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // Enhanced configuration with simplified server testing
      const CONFIG = {
        PRIMARY_SERVER: 'https://numsphere-proxy.onrender.com',
        BACKUP_SERVER: 'https://numsphere-proxy-backup.onrender.com',
        TIMEOUT: 8000,
        MAX_RETRIES: 2,
        OFFLINE_MODE_DELAY: 12000
      };

      let currentRetries = 0;
      let activeServer = null;
      let currentStepIndex = 0;
      let offlineMode = false;
      let connectionAttemptTime = Date.now();

      // Create floating particles
      function createParticles() {
        const particlesContainer = document.getElementById('particles');
        if (!particlesContainer) return;
        
        const particleCount = 15;
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 4 + 's';
          particle.style.animationDuration = (Math.random() * 3 + 2) + 's';
          particlesContainer.appendChild(particle);
        }
      }

      // Update progress and UI elements
      function updateProgress(percentage, message, status = 'loading') {
        const progressBar = document.getElementById('progressBar');
        const messageText = document.getElementById('messageText');
        const statusIndicator = document.getElementById('statusIndicator');
        
        if (progressBar) progressBar.style.width = percentage + '%';
        if (messageText) messageText.textContent = message;
        if (statusIndicator) {
          statusIndicator.className = `status-indicator status-${status}`;
        }
        
        console.log(`Progress: ${percentage}% - ${message} (${status})`);
      }

      // Update server status indicators
      function updateServerStatus(server, status) {
        const primaryDot = document.getElementById('primaryDot');
        const backupDot = document.getElementById('backupDot');
        
        if (server === 'primary' && primaryDot) {
          primaryDot.className = `server-dot status-${status}`;
        } else if (server === 'backup' && backupDot) {
          backupDot.className = `server-dot status-${status}`;
        }
      }

      // Show offline mode option
      function showOfflineMode() {
        const offlineContainer = document.getElementById('offlineContainer');
        const errorContainer = document.getElementById('errorContainer');
        
        if (offlineContainer) offlineContainer.style.display = 'block';
        if (errorContainer) errorContainer.style.display = 'none';
        
        updateProgress(25, 'Servers unavailable - offline mode ready', 'warning');
        updateServerStatus('primary', 'error');
        updateServerStatus('backup', 'error');
      }

      // Show error with better messaging
      function showError(message, canRetry = true, showOffline = false) {
        const errorContainer = document.getElementById('errorContainer');
        const offlineContainer = document.getElementById('offlineContainer');
        const errorMessage = document.getElementById('errorMessage');
        const retryBtn = document.getElementById('retryBtn');
        const loginBtn = document.getElementById('loginBtn');
        
        if (errorMessage) errorMessage.textContent = message;
        if (errorContainer) errorContainer.style.display = 'block';
        if (offlineContainer) offlineContainer.style.display = showOffline ? 'block' : 'none';
        if (retryBtn) retryBtn.style.display = canRetry ? 'inline-block' : 'none';
        if (loginBtn) loginBtn.style.display = 'inline-block';
        
        updateProgress(0, 'Connection failed', 'error');
      }

      // Hide error containers
      function hideError() {
        const errorContainer = document.getElementById('errorContainer');
        const offlineContainer = document.getElementById('offlineContainer');
        if (errorContainer) errorContainer.style.display = 'none';
        if (offlineContainer) offlineContainer.style.display = 'none';
      }

      // Simplified server health check - just test the main server URL
      async function testServerHealth(serverUrl) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.TIMEOUT);
        
        try {
          console.log(`Testing server health: ${serverUrl}`);
          
          // Simple GET request to the server root
          const response = await fetch(`${serverUrl}/status`, {
  method: 'GET',
            signal: controller.signal,
            headers: {
              'Accept': 'application/json',
              'Cache-Control': 'no-cache'
            }
          });
          
          clearTimeout(timeoutId);
          
          // Server is responding if we get any response (even if it's 404 or 405)
          // The important thing is that the server is reachable
          if (response) {
            console.log(`Server ${serverUrl} is responding (${response.status})`);
            return { 
              success: true, 
              data: { status: 'alive', code: response.status }, 
              server: serverUrl 
            };
          }
          
        } catch (error) {
          clearTimeout(timeoutId);
          console.log(`Server ${serverUrl} failed:`, error.message);
        }
        
        return { success: false, server: serverUrl };
      }

      // Enhanced server status check with simplified testing
      async function checkServerStatus() {
        updateProgress(10, 'Checking server connectivity...', 'loading');
        updateServerStatus('primary', 'loading');
        updateServerStatus('backup', 'loading');
        
        try {
          // Test primary server
          let result = await testServerHealth(CONFIG.PRIMARY_SERVER);
          
          if (result.success) {
            activeServer = CONFIG.PRIMARY_SERVER;
            updateProgress(35, 'Connected to primary server', 'success');
            updateServerStatus('primary', 'success');
            updateServerStatus('backup', 'offline');
            console.log('Using primary server:', activeServer);
            return { status: 'ok', server: 'primary', data: result.data };
          } else {
            updateServerStatus('primary', 'error');
          }
          
          // Test backup server
          updateProgress(20, 'Trying backup server...', 'warning');
          updateServerStatus('backup', 'loading');
          
          result = await testServerHealth(CONFIG.BACKUP_SERVER);
          
          if (result.success) {
            activeServer = CONFIG.BACKUP_SERVER;
            updateProgress(35, 'Connected to backup server', 'success');
            updateServerStatus('backup', 'success');
            console.log('Using backup server:', activeServer);
            return { status: 'ok', server: 'backup', data: result.data };
          } else {
            updateServerStatus('backup', 'error');
          }
          
          // Check if we should offer offline mode
          const timeSinceStart = Date.now() - connectionAttemptTime;
          if (timeSinceStart > CONFIG.OFFLINE_MODE_DELAY || currentRetries >= CONFIG.MAX_RETRIES) {
            throw new Error('OFFLINE_MODE_AVAILABLE');
          }
          
          throw new Error('Both servers are currently unavailable. Please try again in a moment.');
          
        } catch (error) {
          console.error('Server connectivity check failed:', error.message);
          if (error.message === 'OFFLINE_MODE_AVAILABLE') {
            throw error;
          }
          throw new Error(`Server connection failed: ${error.message}`);
        }
      }

      // Enhanced authentication validation
      async function validateAuthentication() {
        updateProgress(45, 'Validating authentication...', 'loading');
        
        const isAuthenticated = sessionStorage.getItem('isAuthenticated') || 
                               localStorage.getItem('isAuthenticated');
        const userEmail = sessionStorage.getItem('userEmail') || 
                         localStorage.getItem('userEmail');
        const userName = sessionStorage.getItem('userName') || 
                        localStorage.getItem('userName');
        
        console.log('Authentication check:', { 
          isAuthenticated: !!isAuthenticated, 
          userEmail: userEmail ? '***@' + userEmail.split('@')[1] : 'none',
          userName: userName || 'none',
          offlineMode
        });
        
        if (isAuthenticated !== 'true' || !userEmail) {
          throw new Error('Authentication required - please log in');
        }

        if (offlineMode) {
          updateProgress(55, 'Using offline authentication', 'warning');
          return { 
            valid: true, 
            user: { 
              email: userEmail, 
              name: userName || 'User',
              verified: false,
              offline: true
            },
            server: 'offline'
          };
        }

        try {
          updateProgress(50, 'Verifying with server...', 'loading');
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), CONFIG.TIMEOUT);
          
          const testPayload = new URLSearchParams({
            action: 'verify',
            email: userEmail
          });

          const response = await fetch(activeServer, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Accept': 'application/json'
            },
            body: testPayload,
            signal: controller.signal
          });

          clearTimeout(timeoutId);
          
          updateProgress(60, 'Authentication verified', 'success');
          
          return { 
            valid: true, 
            user: { 
              email: userEmail, 
              name: userName || 'User',
              verified: true,
              offline: false
            },
            server: activeServer
          };
          
        } catch (error) {
          console.warn('Server verification failed, using local auth:', error.message);
          updateProgress(55, 'Using local authentication', 'warning');
          
          return { 
            valid: true, 
            user: { 
              email: userEmail, 
              name: userName || 'User',
              verified: false,
              offline: false
            },
            server: activeServer,
            fallback: true
          };
        }
      }

      // Enhanced user data loading
      async function loadUserData() {
        updateProgress(70, 'Loading user profile...', 'loading');
        
        try {
          const userEmail = sessionStorage.getItem('userEmail') || localStorage.getItem('userEmail');
          const userName = sessionStorage.getItem('userName') || localStorage.getItem('userName') || 'User';
          const userPhone = sessionStorage.getItem('userPhone') || localStorage.getItem('userPhone') || '';
          const userPlan = sessionStorage.getItem('userPlan') || localStorage.getItem('userPlan') || 'Basic';
          
          await new Promise(resolve => setTimeout(resolve, 800));
          
          const userData = {
            profile: { 
              email: userEmail,
              name: userName, 
              phone: userPhone,
              plan: userPlan,
              joinDate: localStorage.getItem('userJoinDate') || new Date().toISOString(),
              preferences: {
                theme: localStorage.getItem('userTheme') || 'default',
                notifications: localStorage.getItem('userNotifications') !== 'false'
              }
            },
            session: {
              loginTime: Date.now(),
              activeServer: activeServer || 'offline',
              serverHealth: activeServer ? 'ok' : 'offline',
              offlineMode: offlineMode || !activeServer
            },
            dashboard: {
              layout: localStorage.getItem('dashboardLayout') || 'default',
              widgets: JSON.parse(localStorage.getItem('dashboardWidgets') || '[]')
            }
          };
          
          sessionStorage.setItem('userData', JSON.stringify(userData));
          sessionStorage.setItem('activeServer', activeServer || 'offline');
          sessionStorage.setItem('sessionStart', Date.now().toString());
          sessionStorage.setItem('offlineMode', offlineMode.toString());
          
          const statusText = offlineMode ? 'User data loaded (offline)' : 'User data loaded successfully';
          const statusType = offlineMode ? 'warning' : 'success';
          updateProgress(85, statusText, statusType);
          
          return userData;
          
        } catch (error) {
          console.error('User data loading failed:', error);
          throw new Error(`Failed to load user data: ${error.message}`);
        }
      }

      // Enhanced dashboard initialization
      async function initializeDashboard() {
        const statusText = offlineMode ? 'Preparing offline dashboard...' : 'Preparing dashboard...';
        updateProgress(90, statusText, 'loading');
        
        try {
          await new Promise(resolve => setTimeout(resolve, 600));
          
          sessionStorage.setItem('dashboardReady', 'true');
          sessionStorage.setItem('loadingComplete', 'true');
          sessionStorage.setItem('fromLoading', 'true');
          
          const finalText = offlineMode ? 'Offline dashboard ready!' : 'Dashboard ready!';
          const finalType = offlineMode ? 'warning' : 'success';
          updateProgress(100, finalText, finalType);
          
          return { 
            ready: true, 
            server: activeServer || 'offline', 
            timestamp: Date.now(),
            offlineMode: offlineMode
          };
          
        } catch (error) {
          throw new Error(`Dashboard initialization failed: ${error.message}`);
        }
      }

      // Complete loading sequence
      function completeLoading() {
        const mode = offlineMode ? 'offline' : 'online';
        console.log(`Loading sequence completed successfully (${mode} mode)`);
        console.log('Active server:', activeServer || 'offline');
        console.log('User data prepared for dashboard');
        
        const container = document.getElementById('loadingContainer');
        if (container) {
          container.classList.add('fade-out');
        }
        
        setTimeout(() => {
          window.location.href = 'dashboard.html';
        }, 800);
      }

      // Main loading sequence with offline support
      async function startLoadingSequence() {
        hideError();
        currentStepIndex = 0;
        activeServer = null;
        connectionAttemptTime = Date.now();
        
        const steps = [
          { func: checkServerStatus, name: 'Server Status Check' },
          { func: validateAuthentication, name: 'Authentication Validation' },
          { func: loadUserData, name: 'User Data Loading' },
          { func: initializeDashboard, name: 'Dashboard Initialization' }
        ];
        
        try {
          for (let i = 0; i < steps.length; i++) {
            currentStepIndex = i;
            console.log(`Executing step ${i + 1}/${steps.length}: ${steps[i].name}`);
            const result = await steps[i].func();
            console.log(`Step ${i + 1} completed:`, result);
            
            await new Promise(resolve => setTimeout(resolve, 200));
          }
          
          console.log('All loading steps completed successfully');
          setTimeout(completeLoading, 1000);
          
        } catch (error) {
          console.error(`Loading sequence failed at step ${currentStepIndex + 1}:`, error);
          
          if (error.message === 'OFFLINE_MODE_AVAILABLE') {
            showOfflineMode();
            return;
          }
          
          if (error.message.includes('Authentication required') || 
              error.message.includes('log in')) {
            showError('Please log in to continue accessing NumSphere.', false);
          } else if (error.message.includes('server') || 
                     error.message.includes('unavailable')) {
            const canRetry = currentRetries < CONFIG.MAX_RETRIES;
            const showOffline = currentRetries >= CONFIG.MAX_RETRIES - 1;
            showError(`Server connection issue: ${error.message}`, canRetry, showOffline);
          } else {
            showError(`Loading failed: ${error.message}`, currentRetries < CONFIG.MAX_RETRIES);
          }
        }
      }

      // Continue in offline mode
      window.continueOffline = function() {
        console.log('Continuing in offline mode');
        offlineMode = true;
        activeServer = null;
        hideError();
        
        currentStepIndex = 1;
        updateProgress(30, 'Continuing in offline mode...', 'warning');
        
        setTimeout(async () => {
          try {
            await validateAuthentication();
            await loadUserData();
            await initializeDashboard();
            setTimeout(completeLoading, 1000);
          } catch (error) {
            console.error('Offline mode initialization failed:', error);
            showError(`Offline mode failed: ${error.message}`, false);
          }
        }, 500);
      };

      // Retry connection with better logic
      window.retryConnection = function() {
        if (currentRetries >= CONFIG.MAX_RETRIES) {
          showOfflineMode();
          return;
        }
        
        currentRetries++;
        console.log(`Retry attempt ${currentRetries}/${CONFIG.MAX_RETRIES}`);
        
        hideError();
        updateProgress(0, 'Retrying connection...', 'loading');
        updateServerStatus('primary', 'loading');
        updateServerStatus('backup', 'loading');
        
        setTimeout(startLoadingSequence, 1000);
      };

      // Go to login page
      window.goToLogin = function() {
        console.log('Redirecting to login page');
        sessionStorage.clear();
        window.location.href = 'login.html';
      };

   window.addEventListener('popstate', function(event) {
        console.log('Browser navigation detected');
        if (event.state && event.state.page === 'loading') {
          // User navigated back to loading page
          location.reload();
        }
      });

      // Handle page visibility changes (tab switching)
      document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'visible') {
          console.log('Page became visible again');
          // Optional: Check if we need to refresh connection status
        }
      });

      // Handle connection status changes
      window.addEventListener('online', function() {
        console.log('Internet connection restored');
        if (offlineMode && !activeServer) {
          updateProgress(15, 'Connection restored - retrying...', 'loading');
          setTimeout(() => {
            currentRetries = 0;
            offlineMode = false;
            startLoadingSequence();
          }, 1000);
        }
      });

      window.addEventListener('offline', function() {
        console.log('Internet connection lost');
        updateProgress(25, 'Connection lost - offline mode available', 'warning');
      });

      // Handle unload events
      window.addEventListener('beforeunload', function() {
        console.log('Page unloading - cleaning up');
        // Clean up any pending timeouts or requests
      });

      // Error handling for uncaught errors
      window.addEventListener('error', function(event) {
        console.error('Uncaught error:', event.error);
        if (!document.getElementById('errorContainer').style.display || 
            document.getElementById('errorContainer').style.display === 'none') {
          showError('An unexpected error occurred. Please try refreshing the page.', true);
        }
      });

      // Initialize the application
      document.addEventListener('DOMContentLoaded', function() {
        console.log('NumSphere Loading Page initialized');
        console.log('Configuration:', CONFIG);
        
        // Create visual effects
        createParticles();
        
        // Add state to browser history
        history.replaceState({ page: 'loading' }, 'Loading - NumSphere', window.location.href);
        
        // Start the loading sequence after a brief delay
        setTimeout(startLoadingSequence, 800);
      });

      // Expose configuration for debugging (development only)
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        window.DEBUG_CONFIG = CONFIG;
        window.DEBUG_STATE = {
          getCurrentRetries: () => currentRetries,
          getActiveServer: () => activeServer,
          getCurrentStep: () => currentStepIndex,
          isOfflineMode: () => offlineMode
        };
        console.log('Debug mode enabled - CONFIG and STATE available in window');
      }

    })();
  </script>
</body>
</html>
